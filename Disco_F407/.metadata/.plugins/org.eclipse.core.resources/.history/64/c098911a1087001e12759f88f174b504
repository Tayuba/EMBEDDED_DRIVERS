/*
 * F407_GPIO_Drivers.c
 *
 *  Created on: March 17, 2023
 *      Author: Ayuba Tahiru
 */


#include 	"F407_GPIO_Drivers.h"
#include <stdint.h>

// Enable Clock
/********************************************************************************
 * @fn					-GPIO_PCLK_Control
 *
 * @brief				-Enable and Disable a clock of a given GPIO port
 *
 * @param[in]			-Takes base address of a given GPIO
 * @param[in]			-Takes Enable value(1) or Disable value(0)
 * @param[in]			-
 *
 * @return				-returns nothing(None)
 *
 * @Note				-GPIO port to be enable or disable base address must be passed
 */

void GPIO_PCLK_Control(GPIOx_RegDef_t *pGPIOx, uint8_t ED){
	if (ED == ENABLE){
		if (pGPIOx == GPIOA){
			GPIOA_PCLK_ENABLE();
		}else if (pGPIOx == GPIOB){
			GPIOB_PCLK_ENABLE();
		}else if (pGPIOx == GPIOC){
			GPIOC_PCLK_ENABLE();
		}else if (pGPIOx == GPIOD){
			GPIOD_PCLK_ENABLE();
		}else if (pGPIOx == GPIOE){
			GPIOE_PCLK_ENABLE();
		}else if (pGPIOx == GPIOF){
			GPIOF_PCLK_ENABLE();
		}else if (pGPIOx == GPIOG){
			GPIOG_PCLK_ENABLE();
		}else if (pGPIOx == GPIOH){
			GPIOH_PCLK_ENABLE();
		}else if (pGPIOx == GPIOI){
			GPIOI_PCLK_ENABLE();
		}
	}else {
		if (pGPIOx == GPIOA){
			GPIOA_PCLK_DISABLE();
		}else if (pGPIOx == GPIOB){
			GPIOB_PCLK_DISABLE();
		}else if (pGPIOx == GPIOC){
			GPIOC_PCLK_DISABLE();
		}else if (pGPIOx == GPIOD){
			GPIOD_PCLK_DISABLE();
		}else if (pGPIOx == GPIOE){
			GPIOE_PCLK_DISABLE();
		}else if (pGPIOx == GPIOF){
			GPIOF_PCLK_DISABLE();
		}else if (pGPIOx == GPIOG){
			GPIOG_PCLK_DISABLE();
		}else if (pGPIOx == GPIOH){
			GPIOH_PCLK_DISABLE();
		}else if (pGPIOx == GPIOI){
			GPIOI_PCLK_DISABLE();
		}
	}

}


// Initialization
/********************************************************************************
 * @fn					-GPIO_Init
 *
 * @brief				-Initialize the various configurations of a given GPIO port
 *
 * @param[in]			-Takes GPIO handle address
 * @param[in]			-
 * @param[in]			-
 *
 * @return				-returns nothing(None)
 *
 * @Note				-None
 */
void GPIO_Init(GPIO_Handle_t *pGPIOxHandle){
	uint32_t temp = 0;  //Tem register
	// 1. Pin mode Config for non Interrupt
	if (pGPIOxHandle->GPIO_PinConfig.GPIO_PinMode <= GPIO_MODE_ANALOG){
		temp = (pGPIOxHandle->GPIO_PinConfig.GPIO_PinMode << (2 * pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber));
		pGPIOxHandle->pGPIOx->MODER &= ~( 0x3 << pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber);
		pGPIOxHandle->pGPIOx->MODER |= temp;


	}else{//Pin mode Config for non Interrupt

	}

	// 2. Output type Config
	temp = 0;
	temp = (pGPIOxHandle->GPIO_PinConfig.GPIO_PinOType << (pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOxHandle->pGPIOx->OTYPER &= ~( 0x1 << pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOxHandle->pGPIOx->OTYPER |= temp;

	// 3. Speed Config
	temp = 0;
	temp = (pGPIOxHandle->GPIO_PinConfig.GPIO_PinSpeed << (2 * pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOxHandle->pGPIOx->OSPEEDR &= ~( 0x3 << pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOxHandle->pGPIOx->OSPEEDR |= temp;

	// 4. Pull Up Pull Down Config
	temp = 0;
	temp = (pGPIOxHandle->GPIO_PinConfig.GPIO_PinPuPdControl << (2 * pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOxHandle->pGPIOx->PUPDR &= ~( 0x3 << pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOxHandle->pGPIOx->PUPDR |= temp;

	// 5.  Alternate Functionality Config
	if (pGPIOxHandle->GPIO_PinConfig.GPIO_PinMode <= GPIO_MODE_ALTFUNC){
		uint8_t temp1, temp2= 0;
		temp1 = pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber / 8;
		temp2 = pGPIOxHandle->GPIO_PinConfig.GPIO_PinNumber % 8;

		pGPIOxHandle->pGPIOx->AFR[temp1] &= ~(0xF << (4 * temp2));
		pGPIOxHandle->pGPIOx->AFR[temp1] |= (pGPIOxHandle->GPIO_PinConfig.GPIO_PinAltFuncMode << (4 * temp2));
	}


}

// De-Initialization
/********************************************************************************
 * @fn					-GPIO_DeInit
 *
 * @brief				-De-Initialize the various configurations of a given GPIO port
 *
 * @param[in]			-Takes GPIO handle address
 * @param[in]			-
 * @param[in]			-
 *
 * @return				-returns nothing(None)
 *
 * @Note				-None
 */
void GPIO_DeInit(GPIOx_RegDef_t *pGPIOx){

	if (pGPIOx == GPIOA){
		GPIOA_RESET();
	}else if (pGPIOx == GPIOB){
		GPIOB_RESET();
	}else if (pGPIOx == GPIOC){
		GPIOC_RESET();
	}else if (pGPIOx == GPIOD){
		GPIOD_RESET();
	}else if (pGPIOx == GPIOE){
		GPIOE_RESET();
	}else if (pGPIOx == GPIOF){
		GPIOF_RESET();
	}else if (pGPIOx == GPIOG){
		GPIOG_RESET();
	}else if (pGPIOx == GPIOH){
		GPIOH_RESET();
	}else if (pGPIOx == GPIOI){
		GPIOI_RESET();
	}
}


//Read, Write data
/********************************************************************************
 * @fn					-GPIO_ReadFromInputPin
 *
 * @brief				-Reads data from GPIO pin
 *
 * @param[in]			-Takes base address of a given GPIO
 * @param[in]			-Takes pin number you want to read from
 * @param[in]			-
 *
 * @return				-returns read value
 *
 * @Note				-None
 */
uint8_t GPIO_ReadFromInputPin(GPIOx_RegDef_t *pGPIOx, uint8_t PinNumber){
	return 0;
}


/********************************************************************************
 * @fn					-GPIO_ReadFromInputPort
 *
 * @brief				-Reads data from GPIO port
 *
 * @param[in]			-Takes base address of a given GPIO
 * @param[in]			-
 * @param[in]			-
 *
 * @return				-returns read value
 *
 * @Note				-None
 */
uint16_t GPIO_ReadFromInputPort(GPIOx_RegDef_t *pGPIOx){
	return 0;
}

/********************************************************************************
 * @fn					-GPIO_WriteToOutputPin
 *
 * @brief				-Write data to GPIO pin
 *
 * @param[in]			-Takes base address of a given GPIO
 * @param[in]			-Takes pin number you want to read from
 * @param[in]			-Takes the value you want to write
 *
 * @return				-returns nothing(None)
 *
 * @Note				-None
 */
void  GPIO_WriteToOutputPin(GPIOx_RegDef_t *pGPIOx, uint8_t PinNumber, uint8_t PinValue){

}

/********************************************************************************
 * @fn					-GPIO_WriteToOutputPort
 *
 * @brief				-Write data to GPIO port
 *
 * @param[in]			-Takes base address of a given GPIO
 * @param[in]			-Takes the value you want to write to the port
 * @param[in]			-
 *
 * @return				-returns nothing(None)
 *
 * @Note				-None
 */
void GPIO_WriteToOutputPort(GPIOx_RegDef_t *pGPIOx, uint16_t PortValue){

}

/********************************************************************************
 * @fn					-GPIO_TogglePin
 *
 * @brief				-Toggles Pin
 *
 * @param[in]			-Takes base address of a given GPIO
 * @param[in]			-Takes the pin number to toggle
 * @param[in]			-
 *
 * @return				-returns nothing(None)
 *
 * @Note				-None
 */
void GPIO_TogglePin(GPIOx_RegDef_t *pGPIOx, uint8_t PinNumber){


}


// IRQ Configuration and Handling
/********************************************************************************
 * @fn					-GPIO_IRQConfig
 *
 * @brief				-Configure Interrupt
 *
 * @param[in]			-Takes IRQ number of the interrupt
 * @param[in]			-Takes the priority of IRQ of the interrupt
 * @param[in]			-Enable or Disable the IRQof the interrupt
 *
 * @return				-returns nothing(None)
 *
 * @Note				-None
 */
void GPIO_IRQConfig(uint8_t IRQ_Number, uint8_t IRQ_Priority, uint8_t IRQ_ED){

}

/********************************************************************************
 * @fn					-GPIO_IRQHandling
 *
 * @brief				-Handle Interrupt pin
 *
 * @param[in]			-Takes interrupt pin to handle
 * @param[in]			-
 * @param[in]			-
 *
 * @return				-returns nothing(None)
 *
 * @Note				-None
 */
void GPIO_IRQHandling(uint8_t PinNumber){


}
